[["index.html", "OV2295 SNV Analysis Chapter 1 Lab Overview 1.1 Instructions", " OV2295 SNV Analysis Andrew McPherson 2024-10-17 Chapter 1 Lab Overview This book contains lab exercises for Module 05: Single Cell Genomics - DNA, as part of the Canadian Bioinformatics Workshop Cancer Analysis (CAN) Workshop. 1.1 Instructions Labs will use Rstudio. Each lab will be provided as blocks of R code you will copy-paste into Rstudio to follow the building of the predictor. Code blocks to be pasted will be in yellow like so. x &lt;- 5 If you hover your mouse over the block, you should see a little clipboard icon. Clicking on that icon will allow you to copy the block in one shot. I would use that. In each case, the result of executing a code block is shown directly after the code, in grey blocks like the one below. These are not intended to be pasted in. 5 "],["ov2295-qc-and-total-copy-number-analysis.html", "Chapter 2 OV2295 QC and Total Copy Number Analysis 2.1 Introduction 2.2 Load the required packages 2.3 Read and QC the copy number data 2.4 Copy number exploration 2.5 Clustering", " Chapter 2 OV2295 QC and Total Copy Number Analysis 2.1 Introduction In this tutorial we will analyze the OV2295 cell line DLP data from the paper “Clonal Decomposition and DNA Replication States Defined by Scaled Single-Cell Genome Sequencing”, Laks et al. (2019) https://doi.org/10.1016/j.cell.2019.10.026. The OV2295 cell lines were generated from a primary, metastasis and relapse specimens obtained from a patient with high grade serous ovarian cancer (see Létourneau et al. (2012), https://doi.org/10.1186/1471-2407-12-379). The cell lines have a high degree of genomic instability, and significant genomic heterogeneity including with respect to large chromosomal changes. The data from the Laks et al. paper is deposited in zenodo (https://doi.org/10.5281/zenodo.3445364). 2.2 Load the required packages This tutorial will rely heavily on the tidyverse packages including ggplot2. Heatmap plotting will use ComplexHeatmap and manipulation of genomic segment data will be done with GenomicRanges. library(tidyverse) library(RColorBrewer) library(vroom) library(ggExtra) library(grid) library(factoextra) library(igraph) library(bluster) library(ggbeeswarm) library(umap) library(cluster) library(Homo.sapiens) library(ggpubr) 2.3 Read and QC the copy number data This data is available from zenodo and can be downloaded with: wget \"https://zenodo.org/record/3445364/files/ov2295_cell_cn.csv.gz\" wget \"https://zenodo.org/record/3445364/files/ov2295_cell_metrics.csv.gz\" The data was analyzed using the DLP single_cell_pipeline: https://github.com/shahcompbio/single_cell_pipeline. We will first read the metrics data, assess the quality of the cells and filter where necessary. The metrics file provided by the many columns but we will focus on quality and total_reads for filtering. Quality is calculated using a classifier trained on manually curated cell quality calls and uses many of the other metrics as features. metrics &lt;- vroom(&quot;ov2295_cell_metrics.csv.gz&quot;) DT::datatable( head(metrics), filter = &#39;top&#39;, options = list( pageLength=50, scrollX=&#39;400px&#39;, autoWidth=TRUE)) Plot a scatterplot of quality by total reads with marginals on the axes. The cloud of cells with significant read count and quality less than 0.75 are cells for which we cannot effectively predict copy number. These cells could either be cycling, or for which the genomic DNA degraded significantly prior to sequencing, or for which tagmentation failed. The plots in this notebook will be using ggplot extensively. I recommend the r4ds tutorials (https://r4ds.had.co.nz/data-visualisation.html) and the ggplot cheat sheet (https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf) for further reference. p &lt;- metrics %&gt;% ggplot(mapping = aes(x=quality, y=total_reads)) + geom_point() + theme(legend.position = &quot;left&quot;) ggMarginal(p, type=&quot;histogram&quot;) Filter reads based on a quality threshold of 0.85 and a total read count threshold of 500k reads. Also filter control cells based on the experimental_condition and sample_id columns. metrics &lt;- metrics %&gt;% filter( quality &gt;= 0.85, total_reads &gt; 500000, !(experimental_condition %in% c(&quot;GM&quot;, &quot;gDNA&quot;)), sample_id %in% c(&quot;SA1090&quot;, &quot;SA921&quot;, &quot;SA922&quot;)) Read in the copy number data. Using vroom::vroom will significantly speed up data loading and using factors for chr and cell_id and ignoring irrelevant columns will reduce the memory footprint. cn &lt;- vroom( &#39;ov2295_cell_cn.csv.gz&#39;, col_types = cols( chr = col_factor(NULL), cell_id = col_factor(NULL) ), col_select = c( chr, start, end, reads, copy, state, cell_id ) ) Subset copy number data by the filtered cell ids in the metrics table. cn &lt;- cn %&gt;% inner_join(metrics[, c(&quot;cell_id&quot;, &quot;sample_id&quot;)], by = &quot;cell_id&quot;) knitr::kable(head(cn), booktabs = TRUE) chr start end reads copy state cell_id sample_id 1 1 500000 22 NA 5 SA922-A90554B-R28-C09 SA922 1 500001 1000000 609 NA 5 SA922-A90554B-R28-C09 SA922 1 1000001 1500000 752 4.574060 5 SA922-A90554B-R28-C09 SA922 1 1500001 2000000 672 3.465685 5 SA922-A90554B-R28-C09 SA922 1 2000001 2500000 931 5.571458 5 SA922-A90554B-R28-C09 SA922 1 2500001 3000000 794 NA 5 SA922-A90554B-R28-C09 SA922 2.4 Copy number exploration We will plot cells using a scatter plot of normalized binned read count data. The data has been processed through HMMCopy analysis as part of the DLP single cell pipeline. The state column contains the prediction of integer copy number state for each cell. The copy column is raw read count normalized for ploidy, gc, and mappability. We will plot copy on the y axis and color by state, and wrap the plotting code in a function for use below. plot_profile &lt;- function(cn) { cn.colors &lt;- c(rev(brewer.pal(n = 3, &quot;Blues&quot;))[1:2], &quot;#CCCCCC&quot;, tail(brewer.pal(n = 8, &quot;OrRd&quot;), 6)) cn.colors &lt;- c(cn.colors, cn.colors[c(9, 9, 9, 9)]) names(cn.colors) &lt;- 0:12 cn %&gt;% mutate(cn_state = factor(state, names(cn.colors))) %&gt;% mutate(chr = factor(chr, levels = c(1:22, &quot;X&quot;, &quot;Y&quot;))) %&gt;% ggplot() + geom_point(mapping = aes(x = start, y = copy, colour = cn_state), size = 0.5) + facet_grid(~chr, scales = &quot;free_x&quot;, space=&quot;free_x&quot;, switch = &quot;x&quot;) + theme(panel.spacing = unit(0.05, &quot;cm&quot;)) + scale_x_continuous(breaks = c()) + scale_color_manual(values = cn.colors, labels = names(cn.colors), drop = FALSE) + scale_y_continuous(breaks = seq(0, 8, by = 1), limit = c(0, 8)) + xlab(&#39;chromosome&#39;) } plot_cell &lt;- function(cn, plot_cell_id) { filter(cn, cell_id == plot_cell_id) %&gt;% plot_profile() } The first cell we will plot is a near diploid cell with some amplified regions and many LOH regions including chromosome 17. The chromosome 17 LOH overlaps with a deliterious TP53 mutation, as is typical of high grade serous ovarian cancers. plot_cell(cn, &quot;SA1090-A96213A-R30-C61&quot;) ## Warning: Removed 740 rows containing missing values or values outside the scale ## range (`geom_point()`). A second cell from the same cell line appears to be baseline tetraploid. Many of the amplified or deleted regions overlap with those of the diploid baseline cell. Copy 3 regions on chromosome 2 and 15 support the tetraploid solution. plot_cell(cn, &quot;SA1090-A96213A-R28-C68&quot;) ## Warning: Removed 762 rows containing missing values or values outside the scale ## range (`geom_point()`). It will be useful to plot all cells together in a heatmap for a high level look at the heterogeneity. Here we rely on the very useful ComplexHeatmap package. The plot takes a GenomicRanges object with columns as cells and rows as regions. A nice tutorial on GenomicRanges can be found here. The plot will use hierarchical clustering to order the cells and provide a summary of the similarity between groups of cells. plot_heatmap &lt;- function(gr, dist_method = &quot;euclidean&quot;){ #&#39; plot a heatmap with chromosome boundaries #&#39; the order of the rows can be customized here #&#39; its a simple distance based clustering #&#39; #&#39; Adapted from code published by Velazquez-Villarreal et al. (2020): #&#39; https://www.nature.com/articles/s42003-020-1044-8 #&#39; #&#39; Uses the very useful ComplexHeatmap package: #&#39; https://jokergoo.github.io/ComplexHeatmap-reference/book/ gr &lt;- GenomeInfoDb::sortSeqlevels(gr) gr &lt;- sort(gr) mat &lt;- as.matrix(GenomicRanges::mcols(gr)) mat &lt;- t(mat) hr &lt;- hclust(get_dist(mat, method = dist_method), method = &quot;average&quot;) hr = as.dendrogram(hr) # chromosome boundaries and midpoints for annotation chr_ids = GenomicRanges::seqnames(gr)@values chr_lengths = GenomicRanges::seqnames(gr)@lengths chr_props = chr_lengths / length(gr) mids = cumsum(chr_props) - (chr_props / 2) boundaries = cumsum(chr_props) boundaries = boundaries[1:length(boundaries)-1] abline_x = rep(boundaries, each=2) abline_y &lt;- rep(c(0,1), times=length(boundaries)) abline_ids &lt;- rep(1:length(boundaries),each=2) #annotation to label chromosomes ha_column = ComplexHeatmap::HeatmapAnnotation(cn = function(index) { grid.text(chr_ids,x=mids,y=1,just = c(&quot;center&quot;, &quot;top&quot;),gp=gpar(col=&quot;#202020&quot;,fontsize=6)) }) # the main heatmap cn.colors &lt;- c(rev(brewer.pal(n = 3, &quot;Blues&quot;))[1:2], &quot;#CCCCCC&quot;, tail(brewer.pal(n = 8, &quot;OrRd&quot;), 6)) cn.colors &lt;- c(cn.colors, cn.colors[c(9, 9, 9, 9)]) names(cn.colors) &lt;- 0:12 hm &lt;- ComplexHeatmap::Heatmap( matrix = mat, name = &quot;ploidy&quot;, col = cn.colors, cluster_rows = hr, cluster_columns = FALSE, show_row_names = FALSE, bottom_annotation = ha_column, column_title = &quot;CNV heatmap&quot;, use_raster = TRUE, ) ComplexHeatmap::draw(hm, row_dend_side = &quot;left&quot;) ComplexHeatmap::decorate_heatmap_body(&quot;ploidy&quot;, { grid.polyline( x = abline_x, y = abline_y, id = abline_ids, gp = gpar(lty = 1, lwd = 1)) }) } Plotting SA1090 (the primary sample), we can see that there are two major groups, a baseline diploid and a baseline tetraploid group. Both groups harbour additional heterogeneity. Looking closely, it appears that many of the patterns that distinguish populations within the diploid group are also found in the tetraploid group. gr &lt;- cn %&gt;% filter(sample_id == &quot;SA1090&quot;) %&gt;% dplyr::select(chr, start, end, state, cell_id) %&gt;% pivot_wider(names_from = cell_id, values_from = state) %&gt;% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE) plot_heatmap(gr) ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. The default distance method for generating the hierarchical clustering was eucldean, which will naturally result in large distances between diploid and tetraploid cells. Alternative distance methods can be specified, see the get_dist function from factoextras. If we use pearson correlation as the distance method, we see significant mixing of the diploid and tetraploid populations indicating that tetraploidization is occuring independently and sporadically throughout the population. plot_heatmap(gr, dist_method = &quot;pearson&quot;) ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. If we plot total_reads by mean_copy (average ploidy) there appears to be a relationship, likely due to the fact that tetraploid cells will have twice the DNA available and take up more sequencing realestate. Classifying diploid and tetraploid, the difference in mean total_reads is highly significant, further evidence the tetraploid cells are truly tetraploid. Some cells classified as diploid may in fact be tetraploid with a perfect doubling of all chromosomes though this would be difficult to determine without orthogonal experiments. Note that we havent ruled out doublets with certainty. metrics %&gt;% filter(sample_id == &quot;SA1090&quot;) %&gt;% ggplot(aes(x=mean_copy, y=total_reads)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula= y~x) metrics %&gt;% filter(sample_id == &quot;SA1090&quot;) %&gt;% mutate(is_polyploid = mean_copy &gt; 2.5) %&gt;% ggplot(aes(x=is_polyploid, y=total_reads)) + geom_boxplot() + stat_compare_means(label.x = 1.3) 2.5 Clustering In order to further understand the population structure we can cluster the cells by their copy number profiles. It is worth noting that for some datasets, clustering is inappropriate. If the population of cells is continuously evolving and accruing neutral copy number changes, the cells will lie on a continuum of copy number change. Any maximal set of related cells could be considered a ‘cluster’ if a copy number change exists specific to that set of cells. In such a case phylogenetic representation is more appropriate. However, in many real datasets sets of cells will cluster due to either selection having favoured the expansion of some cell populations and the extinction of others. We will first cluster the cells using k-means. Independent segmentation of each cell using HMMCopy can produce small differences in segment boundaries that may affect clustering. We will thus cluster based on the raw copy number (‘copy’ column) instead of the HMMCopy state. Start by creating a matrix of raw copy number values, filtering bins with NaNs in any cell and scaling the data to allow clustering of cells with dissimilar ploidy. gr &lt;- cn %&gt;% dplyr::select(chr, start, end, copy, cell_id) %&gt;% pivot_wider(names_from = cell_id, values_from = copy) %&gt;% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE) # Remove bins with any nan across any cell gr &lt;- gr[complete.cases(GenomicRanges::mcols(gr))] # Create matrix, remove bins that are nan across any cells mat &lt;- as.matrix(GenomicRanges::mcols(gr)) # Optionally normalize the copy number, this will group cells regardless of ploidy mat &lt;- scale(mat) mat &lt;- t(mat) We will then use PCA to transform the data to a reduced dimensionality representation. In bin level copy number data, many of the bins will be highly correlated especially with neighboring bins subject to the same copy number change. PCA will effectively compress multiple correlated bins into a single dimension. Working with the top PCA components will be desirable because it decreases the computational burden of downstream computation (ie clustering) and reduces noise by averaging across multiple bins. PCA can be run using the prcomp function: mat.pca &lt;- prcomp(mat) It can be informative to plot the PCA loadings of the top components. The loadings for a given component represent how much each bin contributes to that component. Large positive or negative values indicate a strong positive or negative correlation of the bin with the component respectively. Values close to 0 indicate the bin is uncorrelated with the component. The PCA loading plot can be helpful in identifying problematic noisy bins. These bins will show up as isolated spikes in the PCA loading plot. The first PCA plotted below looks unproblematic. Try setting the value of a bin to 1000 for a subset of cells and redoing the PCA to see the effect. pc = &quot;PC1&quot; gr.pca &lt;- granges(gr) GenomicRanges::mcols(gr.pca) &lt;- list(PC=mat.pca$rotation[, pc]) GenomicRanges::as.data.frame(gr.pca) %&gt;% tibble() %&gt;% dplyr::rename(chr=seqnames) %&gt;% ggplot() + geom_point(mapping = aes(x = start, y = PC), size = 0.5) + facet_grid(~chr, scales = &quot;free_x&quot;, space=&quot;free_x&quot;, switch = &quot;x&quot;) + theme(panel.spacing = unit(0.05, &quot;cm&quot;)) + scale_x_continuous(breaks = c()) + xlab(&#39;chromosome&#39;) Now run k-means on the first 50 PCs. Use 12 cluster centers and 100 restarts and set a seed for consistency. set.seed(42) clust.kmeans &lt;- kmeans(mat.pca$x[, 1:50], centers=12, nstart=100) clust &lt;- clust.kmeans$cluster UMAP is a non-linear dimensionality reduction technique favoured for its ability to preserve much of the structure of the data in a 2-D plot. We can use UMAP to visualize the clustering. mat.umap &lt;- umap(mat) mat.umap.tbl &lt;- tibble(x=mat.umap$layout[,1], y=mat.umap$layout[,2], cluster=factor(clust)) ggplot(mat.umap.tbl) + geom_point(aes(x=x, y=y, color=cluster)) We can also assess the clustering using the silhouette method. Briefly, the silhouette width statistic is calculated based on the mean distance of a datapoint to every other datapoint in the same cluster, and the mean distance to datapoints in the next closest cluster. A silhouette width less than 0 could indicate the cell may be better assigned to a different cluster, the cell is an outlier, or the data are not spherically distributed around cluster centers. sil.approx &lt;- approxSilhouette(mat, clusters=clust) sil.data &lt;- as.data.frame(sil.approx) sil.data$closest &lt;- factor(ifelse(sil.data$width &gt; 0, clust, sil.data$other)) sil.data$cluster &lt;- factor(clust) ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) + ggbeeswarm::geom_quasirandom(method=&quot;smiley&quot;) We used k=12 cluster centers somewhat arbitrarily. Many strategies exist for selecting an appropriate value for k. For instance, we could use the gap statistic to select an optimal k as shown below. The optimal number of clusters suggested by this method may be less than expected reflecting the issues with clustering, especially k-means clustering, on this type of data. Generally speaking, differences between sub-populations will vary widely in scale with some populations well separated by large copy number changes and other derivative populations differing only by a few changes. gaps &lt;- clusGap(mat.pca$x[, 1:50], kmeans, K.max=30, B=100) best.k &lt;- maxSE(gaps$Tab[,&quot;gap&quot;], gaps$Tab[,&quot;SE.sim&quot;]) as_tibble(gaps$Tab) %&gt;% mutate(k=factor(1:30)) %&gt;% ggplot() + geom_point(aes(x=k, y=gap)) + geom_vline(xintercept=best.k, col=&quot;red&quot;, lwd=0.5, lty=2) + xlab(&quot;Number of clusters&quot;) + ylab(&quot;Gap statistic&quot;) Alternative clustering approaches are possible, see this excellent scRNA tutorial for ideas. For instance, a graph based clustering approach could work better for clustering copy number data in some cases, as graph based methods will not favour spherical clusters. In order to visualize the cluster copy number, lets modify our heatmap plotting function to take in a clustering, order the rows by each cell’s cluster label, and annotate the clusters on the left side of the heatmap. plot_cluster_heatmap &lt;- function(gr, clust){ #&#39; plot a heatmap with chromosome boundaries #&#39; the order of the rows can be customized here #&#39; its a simple distance based clustering #&#39; #&#39; Adapted from code published by Velazquez-Villarreal et al. (2020): #&#39; https://www.nature.com/articles/s42003-020-1044-8 #&#39; #&#39; Uses the very useful ComplexHeatmap package: #&#39; https://jokergoo.github.io/ComplexHeatmap-reference/book/ gr &lt;- GenomeInfoDb::sortSeqlevels(gr) gr &lt;- sort(gr) sorted_clust = sort(clust) mat &lt;- as.matrix(GenomicRanges::mcols(gr)) mat &lt;- t(mat) mat &lt;- mat[names(sorted_clust),] # chromosome boundaries and midpoints for annotation chr_ids = GenomicRanges::seqnames(gr)@values chr_lengths = GenomicRanges::seqnames(gr)@lengths chr_props = chr_lengths / length(gr) mids = cumsum(chr_props) - (chr_props / 2) boundaries = cumsum(chr_props) boundaries = boundaries[1:length(boundaries)-1] abline_x = rep(boundaries, each=2) abline_y &lt;- rep(c(0,1), times=length(boundaries)) abline_ids &lt;- rep(1:length(boundaries),each=2) # annotation to label chromosomes ha_column = ComplexHeatmap::HeatmapAnnotation(cn = function(index) { grid.text(chr_ids,x=mids,y=1,just = c(&quot;center&quot;, &quot;top&quot;),gp=gpar(col=&quot;#202020&quot;,fontsize=6)) }) # cluster annotation cluster_colors = rainbow(length(unique(sorted_clust))) names(cluster_colors) = unique(sorted_clust) ha_row = ComplexHeatmap::rowAnnotation(cluster = factor(sorted_clust), col = list(cluster = cluster_colors)) # the main heatmap cn.colors &lt;- c(rev(brewer.pal(n = 3, &quot;Blues&quot;))[1:2], &quot;#CCCCCC&quot;, tail(brewer.pal(n = 8, &quot;OrRd&quot;), 6)) cn.colors &lt;- c(cn.colors, cn.colors[c(9, 9, 9, 9)]) names(cn.colors) &lt;- 0:12 hm = ComplexHeatmap::Heatmap( matrix = mat, name = &quot;ploidy&quot;, col = cn.colors, cluster_rows = FALSE, cluster_columns = FALSE, show_row_names = FALSE, bottom_annotation = ha_column, left_annotation = ha_row, column_title = &quot;CNV heatmap&quot;, use_raster = TRUE, ) ComplexHeatmap::draw(hm) ComplexHeatmap::decorate_heatmap_body(&quot;ploidy&quot;, { grid.polyline( x = abline_x, y = abline_y, id = abline_ids, gp = gpar(lty = 1, lwd = 1)) }) } gr &lt;- cn %&gt;% dplyr::select(chr, start, end, state, cell_id) %&gt;% pivot_wider(names_from = cell_id, values_from = state) %&gt;% GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE) plot_cluster_heatmap(gr, clust) ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. We can also merge cell copy number data by cluster to show aggregate cluster level copy number. clust.df &lt;- enframe(clust.kmeans$cluster) %&gt;% dplyr::rename(cell_id = name, cluster = value) clust.sizes &lt;- enframe(table(clust.df$cluster)) %&gt;% dplyr::rename(cell_id = name, size = value) %&gt;% filter(size &gt;= 10) cn_clust &lt;- cn %&gt;% inner_join(clust.df) %&gt;% group_by(chr, start, end, cluster) %&gt;% summarize(copy = mean(copy), state = median(state)) ## Joining with `by = join_by(cell_id)` ## `summarise()` has grouped output by &#39;chr&#39;, &#39;start&#39;, &#39;end&#39;. You can override using the `.groups` argument. cn_clust %&gt;% filter(cluster == 7) %&gt;% plot_profile() ## Warning: Removed 806 rows containing missing values or values outside the scale ## range (`geom_point()`). cn_clust %&gt;% filter(cluster == 8) %&gt;% plot_profile() ## Warning: Removed 957 rows containing missing values or values outside the scale ## range (`geom_point()`). cn_clust %&gt;% filter(cluster == 9) %&gt;% plot_profile() ## Warning: Removed 915 rows containing missing values or values outside the scale ## range (`geom_point()`). There appears to be a deletion on chromosome 5. Navigate here to see why: http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&amp;lastVirtModeType=default&amp;lastVirtModeExtraState=&amp;virtModeType=default&amp;virtMode=0&amp;nonVirtPosition=&amp;position=chr5%3A67500000%2D72000002&amp;hgsid=1117136619_dGtW3EEOeJAIG6cYbSGFZwGwyLzb subset.gr &lt;- cn_clust %&gt;% filter(copy &lt; 0.2, chr != &quot;Y&quot;) %&gt;% makeGRangesFromDataFrame() knitr::kable(subset.gr, booktabs = TRUE) seqnames start end width strand 5 69000001 69500000 5e+05 * 5 69000001 69500000 5e+05 * 5 69000001 69500000 5e+05 * 5 69000001 69500000 5e+05 * 5 69000001 69500000 5e+05 * 5 69000001 69500000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 69500001 70000000 5e+05 * 5 70000001 70500000 5e+05 * 5 70000001 70500000 5e+05 * 5 70000001 70500000 5e+05 * 5 70000001 70500000 5e+05 * Finally, lets look at the gene content of some of the high level amplifications. First read in a list of known oncogenic amplified genes from the cancer gene census. Read hg19 genes from TxDb.Hsapiens.UCSC.hg19.knownGene and be careful to rename chromosomes, ie “chr9” -&gt; “9”. Add gene symbols from org.Hs.egSYMBOL. cencus.amps &lt;- read_csv(&#39;Census_ampThu\\ Apr\\ 16\\ 15_35_36\\ 2020.csv&#39;) %&gt;% dplyr::rename(symbol = `Gene Symbol`) ## Rows: 24 Columns: 7 ## ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): Gene Symbol, Name, Genome Location, Tumour Types(Somatic), Synonyms ## dbl (2): Entrez GeneId, Tier ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # read human genes, normalize chromosome names human.genes &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) ## 403 genes were dropped because they have exons located on both strands ## of the same reference sequence or on more than one reference sequence, ## so cannot be represented by a single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a ## GRangesList object, or use suppressMessages() to suppress this message. human.genes &lt;- renameSeqlevels(human.genes, sub(&quot;chr&quot;, &quot;&quot;, seqlevels(human.genes))) # add gene symbol from org.Hs.egSYMBOL GenomicRanges::mcols(human.genes) &lt;- tibble(gene_id=human.genes$gene_id) %&gt;% left_join(tibble(as.data.frame(org.Hs.egSYMBOL))) ## Joining with `by = join_by(gene_id)` # subset by cancer gene cencus amps cencus.amps.genes &lt;- human.genes[(elementMetadata(human.genes)[,&#39;symbol&#39;] %in% cencus.amps$symbol)] Filter copy number for high level events, then subset by overlap with gene regions. The SOX2 gene is amplified. subset.gr &lt;- cn_clust %&gt;% filter(copy &gt; 10) %&gt;% makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE) subset.genes &lt;- subsetByOverlaps(cencus.amps.genes, subset.gr) knitr::kable(subset.genes, booktabs = TRUE) seqnames start end width strand gene_id symbol 3 181429712 181432223 2512 + 6657 SOX2 Overlapping the SOX2 region with all cluster copy number we find that SOX2 is subclonally amplified. all.gr &lt;- cn_clust %&gt;% makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE) subsetByOverlaps(all.gr, subset.genes) %&gt;% as_tibble() %&gt;% ggplot() + geom_col(aes(x=factor(cluster), y=copy)) "],["allele-specific-analysis-of-ov2295.html", "Chapter 3 Allele specific analysis of OV2295 3.1 Introduction 3.2 Load the required packages 3.3 Read data and QC 3.4 Clustering and heatmaps 3.5 Plot BAF of cells or clusters", " Chapter 3 Allele specific analysis of OV2295 3.1 Introduction In this tutorial we will further analyze the OV2295 cell line DLP data, this time focusing on the allele specific copy number calling using the method described in “Single cell genomic variation induced by mutational processes in cancer”, Funnell et al. (2022) https://doi.org/10.5281/zenodo.6998936. The data from the Funnell et al. paper is deposited in zenodo (https://doi.org/10.5281/zenodo.6998936). 3.2 Load the required packages For this part of the tutorial we will use the signals R package developed for the Funnell et al paper. Documentation for signals can be found here: https://shahcompbio.github.io/signals/. library(vroom) library(signals) 3.3 Read data and QC First read in the allele specific copy number data produced by signals. hscn &lt;- vroom( &quot;ov2295_hscn.csv.gz&quot;, col_types = cols( chr = col_factor(NULL), cell_id = col_factor(NULL), state_AS_phased = col_factor(NULL), state_phase = col_factor(NULL), ), col_select = c( cell_id, chr, start, end, copy, state, alleleA, alleleB, totalcounts, BAF, state_min, A, B, state_AS_phased, state_phase, ), ) DT::datatable( head(hscn), filter = &#39;top&#39;, options = list( pageLength=50, scrollX=&#39;400px&#39;, autoWidth=TRUE)) We can visualize the distribution of SNP VAF per allele specific copy number state using the plotBAFperstate function. plotBAFperstate(hscn, maxstate = 10) 3.4 Clustering and heatmaps Similar to the section on total copy number, we can cluster the copy number data. The signals function umap_clustering clusters the cells by their copy number profiles by first creating a umap projection then clustering in that reduced dimension space. clustering &lt;- umap_clustering(hscn, field = &quot;copy&quot;, seed = 1) ggplot(clustering$clustering, aes(x = umap1, y = umap2, color = clone_id)) + geom_point() + theme_minimal() + labs(x = &quot;X Axis Label&quot;, y = &quot;Y Axis Label&quot;, color = &quot;Color Legend&quot;) We can then plot the total copy number using plotHeatmap. The plot includes a clustering dendrogram (not necessarily a phylogenetic tree). plotHeatmap(hscn, plotcol = &quot;state&quot;, tree = clustering$tree, clusters = clustering$clustering) In addition we can then plot the allele B copy number using plotHeatmap. plotHeatmap(hscn, plotcol = &quot;B&quot;, tree = clustering$tree, clusters = clustering$clustering) Or we can plot the allele specific state which will give a better view of which regions are LOH of either A or B. plotHeatmap(hscn, plotcol = &quot;state_phase&quot;, tree = clustering$tree, clusters = clustering$clustering) 3.5 Plot BAF of cells or clusters Finally we can plot both the BAF signal of a single cell. plotCNprofileBAF(hscn, cellid = &quot;SA921-A90554A-R03-C44&quot;) Or of a cluster of cells. consensus_clusters &lt;- consensuscopynumber(hscn, cl = clustering$clustering) plotCNprofileBAF(consensus_clusters, cellid = &quot;A&quot;, y_axis_trans = &quot;squashy&quot;) Further analyses: cluster on allele specific copy number using signals, does the clustering change? identify instances of mirrored allelic imbalance find tumor supressor genes in LOH regions "],["ov2295-snv-analysis.html", "Chapter 4 OV2295 SNV Analysis 4.1 Introduction 4.2 Load the required packages 4.3 Read the SNV and Cell tables 4.4 View the block matrix", " Chapter 4 OV2295 SNV Analysis 4.1 Introduction In this tutorial we will explore the SNVs of the OV2295 cell lines. We have run sbmclone (citation: https://academic.oup.com/bioinformatics/article/36/Supplement_1/i186/5870493, github: https://github.com/raphael-group/SBMClone) to produce a joint clustering of both cells and SNVs. This data is available from zenodo and can be downloaded with: TBD 4.2 Load the required packages library(tidyverse) library(vroom) 4.3 Read the SNV and Cell tables The SNV table shows all detected SNVs used in the analysis, and their assignment to an SNV ‘block’. snvs &lt;- vroom(&quot;ov2295_snvs.csv&quot;) DT::datatable( head(snvs, 5), filter = &#39;top&#39;, options = list( pageLength=50, scrollX=&#39;400px&#39;, autoWidth=TRUE)) The cell table provides the cell block to which each cell was assigned. cells &lt;- vroom(&quot;ov2295_cells.csv&quot;) DT::datatable( head(cells, 5), filter = &#39;top&#39;, options = list( pageLength=50, scrollX=&#39;400px&#39;, autoWidth=TRUE)) 4.4 View the block matrix The alt fractions table shows the fraction of alt reads across all SNVs for all cells within an SNV / block pair. alt_fractions &lt;- vroom(&quot;ov2295_snvs_alt_fraction.csv&quot;) alt_fractions_wide &lt;- alt_fractions %&gt;% pivot_wider(names_from = cell_block_assignment, values_from = alt_fraction) alt_fractions_mat &lt;- as.matrix(alt_fractions_wide[, -1]) # Exclude the first column to keep only the numeric values rownames(alt_fractions_mat) &lt;- alt_fractions_wide$snv_block_assignment hm &lt;- ComplexHeatmap::Heatmap( matrix = alt_fractions_mat, name = &quot;fraction alt reads&quot;, cluster_rows = TRUE, cluster_columns = TRUE, show_row_names = TRUE, row_title = &quot;snv block&quot;, column_title = &quot;cell block&quot;, use_raster = TRUE, ) ComplexHeatmap::draw(hm, row_dend_side = &quot;left&quot;) Further analyses: try visualizing the copy number data clustered by the cell blocks, how does this compare to the copy number clustering? construct a phylogenetic tree for the SNV/cell blocks. Does this contradict the dendrogram from copy number clustering? what are the signatures of the branch specific vs common SNVs? "]]
